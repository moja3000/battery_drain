<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>iPad Burner (REST)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden;
      font-family: ui-monospace, system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }
    .wrap{ position:fixed; inset:0; background:#000; }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }
    .hud{ position:absolute; top:12px; left:12px; right:12px; display:grid; gap:10px; pointer-events:none; }
    .panel{ pointer-events:auto; background:rgba(0,0,0,0.65); border:1px solid rgba(0,255,180,0.15);
      border-radius:12px; padding:10px 12px; color:rgba(0,255,180,0.9); box-shadow:0 6px 20px rgba(0,0,0,0.35); }
    .btns{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    button{ appearance:none; border:1px solid rgba(0,255,180,0.25); background:rgba(0,0,0,0.55);
      color:rgba(0,255,180,0.92); padding:8px 10px; border-radius:10px; font-size:12px; }
    button:active{ transform: translateY(1px); }
    .diag{ font-size:12px; line-height:1.35; white-space:pre-line; opacity:0.95; margin-top:10px; }
    .overlay{ position:absolute; bottom:12px; right:12px; pointer-events:none; background:rgba(0,0,0,0.45);
      border:1px solid rgba(0,255,180,0.12); color:rgba(0,255,180,0.9); padding:8px 10px; border-radius:10px;
      font-size:12px; font-family: ui-monospace, monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c2d"></canvas>
    <canvas id="glc"></canvas>

    <div class="hud">
      <div class="panel">
        <div style="font-size:12px; opacity:0.95;">REST mode (charging / safety)</div>

        <div class="btns">
          <button id="goBurn">Open BURN</button>
        </div>

        <div class="diag" id="diag"></div>
      </div>
    </div>

    <div class="overlay" id="overlay">REST…</div>
  </div>

<script>
(() => {
  let fps = 0, last = 0, rafId = 0;

  const diag = { glOK:false, canvasW:0, canvasH:0, rafTicks:0, dpr:1, shaderIters:0, passes:1, particles:0 };

  const diagEl = document.getElementById('diag');
  const overlayEl = document.getElementById('overlay');
  const goBurnBtn = document.getElementById('goBurn');

  const c2d = document.getElementById('c2d');
  const glc = document.getElementById('glc');
  let ctx;

  let gl, prog, vbo;
  let isGL2 = false;
  let particles = [];

  // REST는 가볍게: DPR 낮게, passes=1, 워커=0
  function restParams() {
    const baseDpr = window.devicePixelRatio || 1;
    const dpr = Math.max(1, Math.min(1.5, baseDpr));   // 낮게 고정
    const particlesN = 300;                            // 적게
    const shaderIters = 220;                           // 낮게
    return { dpr, particlesN, shaderIters, passes: 1 };
  }

  function init2D(particlesN) {
    ctx = c2d.getContext('2d', { alpha: false });
    const w = c2d.width, h = c2d.height;
    particles = Array.from({length: particlesN}, () => ({
      x: Math.random()*w, y: Math.random()*h,
      vx: (Math.random()-0.5)*0.7, vy: (Math.random()-0.5)*0.7
    }));
    diag.particles = particlesN;
  }

  function draw2D() {
    const w = c2d.width, h = c2d.height;
    ctx.fillStyle = "rgb(0,0,0)";
    ctx.fillRect(0,0,w,h);

    ctx.globalAlpha = 0.03;
    ctx.fillStyle = "#020202";
    for (const p of particles) {
      p.x += p.vx; p.y += p.vy;
      if (p.x<0 || p.x>w) p.vx *= -1;
      if (p.y<0 || p.y>h) p.vy *= -1;
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.globalAlpha = 1.0;
  }

  function compileShader(gl, src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
    return s;
  }

  function buildProgram(shaderIters) {
    if (!gl) {
      gl = glc.getContext("webgl2", { antialias:false, powerPreference:"low-power", alpha:false })
        || glc.getContext("webgl",  { antialias:false, alpha:false });
      if (!gl) { diag.glOK = false; return false; }
      isGL2 = !!gl.drawArraysInstanced;
    }

    if (prog) { try { gl.deleteProgram(prog); } catch(e){} prog = null; }

    const vertGL2 = `#version 300 es
      in vec2 p; void main(){ gl_Position = vec4(p,0.0,1.0); }`;

    const fragGL2 = `#version 300 es
      precision mediump float;
      uniform float uT;
      out vec4 C;
      float h(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); }
      void main(){
        vec3 col = vec3(0.03);
        for (int i=0; i<${shaderIters}; i++){
          float t = uT*0.0003 + float(i)*0.04;
          col = abs(cos(col*t + vec3(h(gl_FragCoord.xy+t), h(gl_FragCoord.yx-t), h(gl_FragCoord.yy+t))));
        }
        C = vec4(0.0,0.0,0.0,1.0);
      }`;

    const vertGL1 = `attribute vec2 p; void main(){ gl_Position = vec4(p,0.0,1.0); }`;

    const fragGL1 = `
      precision mediump float;
      uniform float uT;
      float h(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); }
      void main(){
        vec3 col = vec3(0.03);
        for (int i=0; i<${Math.max(120, Math.round(shaderIters*0.7))}; i++){
          float t = uT*0.0003 + float(i)*0.04;
          col = abs(cos(col*t + vec3(h(gl_FragCoord.xy+t), h(gl_FragCoord.yx-t), h(gl_FragCoord.yy+t))));
        }
        gl_FragColor = vec4(0.0,0.0,0.0,1.0);
      }`;

    const vs = compileShader(gl, isGL2 ? vertGL2 : vertGL1, gl.VERTEX_SHADER);
    const fs = compileShader(gl, isGL2 ? fragGL2 : fragGL1, gl.FRAGMENT_SHADER);

    prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(prog)); diag.glOK = false; return false; }

    if (!vbo) {
      const quad = new Float32Array([-1,-1,  1,-1,  -1,1,   -1,1,  1,-1,  1,1]);
      vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
    }

    diag.glOK = true;
    diag.shaderIters = shaderIters;
    return true;
  }

  function drawGL(t, passes) {
    if (!gl || !prog) return;
    const w = glc.width, h = glc.height;
    gl.viewport(0,0,w,h);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(prog);

    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const loc = gl.getAttribLocation(prog, "p");
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

    const uT = gl.getUniformLocation(prog, "uT");
    gl.uniform1f(uT, t);

    for (let k=0; k<passes; k++) gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  function setHiDPISize(dpr) {
    const W = window.innerWidth;
    const H = window.innerHeight;
    const ww = Math.floor(W * dpr);
    const hh = Math.floor(H * dpr);
    c2d.width = ww; c2d.height = hh;
    glc.width = ww; glc.height = hh;
    diag.canvasW = ww; diag.canvasH = hh; diag.dpr = dpr;
  }

  function applyRest() {
    const p = restParams();
    setHiDPISize(p.dpr);
    init2D(p.particlesN);
    buildProgram(p.shaderIters);
    diag.passes = p.passes;
    renderDiag(16);
  }

  function renderDiag(dt) {
    fps = Math.max(1, Math.round(1000/Math.max(1, dt || 16)));
    overlayEl.textContent = `REST | FPS ${fps} | passes 1`;
    diagEl.textContent =
`GL OK: ${diag.glOK ? "yes" : "no"}
Mode: rest.html
Canvas(px): ${diag.canvasW}×${diag.canvasH} (dpr≈${diag.dpr.toFixed(2)})
Workers: 0
2D particles: ${diag.particles}
Shader iters: ${diag.shaderIters}
GL passes/frame: ${diag.passes}
RAF ticks: ${diag.rafTicks}`;
  }

  function loop(ts) {
    const dt = ts - last; last = ts;

    draw2D();
    drawGL(ts, 1);

    diag.rafTicks++;
    renderDiag(dt);
    rafId = requestAnimationFrame(loop);
  }

  goBurnBtn.addEventListener('click', () => { location.href = "./burn.html"; });
  window.addEventListener('resize', () => applyRest());
  window.addEventListener('beforeunload', () => { try { cancelAnimationFrame(rafId); } catch(e){} });

  // Start
  applyRest();
  last = performance.now();
  rafId = requestAnimationFrame(loop);
})();
</script>
</body>
</html>
