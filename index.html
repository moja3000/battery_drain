<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ultimate Battery Burner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: ui-monospace, system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      overflow: hidden; /* 스크롤 방지 */
    }
    .canvas-section {
      height: 100vh;
      width: 100vw;
      position: relative;
      background: #020202;
      color: #0f0;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    /* 눈에 거슬리지 않도록 아주 어둡게 설정 */
    #glCanvas { opacity: 0.8; }
    
    .status-panel {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(0,0,0,0.7);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid #333;
      color: #44ff44;
      font-size: 12px;
      line-height: 1.5;
      pointer-events: none;
      z-index: 10;
    }
    .warning {
      color: #ff4444;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
  </style>
</head>
<body>

  <div class="canvas-section">
    <canvas id="c2d"></canvas>
    <canvas id="glCanvas"></canvas>
    
    <div class="status-panel" id="statusPanel">
      <div class="warning">⚠️ BATTERY DRAINER ACTIVE</div>
      <div id="stats">Initializing...</div>
    </div>
  </div>

  <script>
    // ===== Configuration =====
    // 화면에 티가 안 나게 하려면 값을 낮추세요. 배터리는 1.0이 제일 빠릅니다.
    // 0.005 정도면 거의 검은색으로 보이지만 GPU는 풀가동합니다.
    const VISUAL_INTENSITY = 0.005; 
    
    let running = true;
    let frameCount = 0;
    let workerCount = 0;
    let networkReqs = 0;

    const statsEl = document.getElementById('stats');

    // ===== 1. Network Burner (통신 모듈 활성화 유지) =====
    // 지속적인 요청을 통해 Wifi/LTE 칩셋이 Low power mode로 가는 것을 방지
    function startNetworkBurner() {
      const burnNetwork = () => {
        if (!running) return;
        // 캐시 방지를 위해 랜덤 쿼리 스트링 사용
        // 자신의 페이지를 호출하거나 가벼운 리소스를 호출
        fetch(window.location.href + '?cache_bust=' + Math.random())
          .then(() => { networkReqs++; })
          .catch(() => {}) // 에러 무시
          .finally(() => {
             // 너무 빠르면 브라우저가 차단하므로 약간의 텀을 둠
             setTimeout(burnNetwork, 200); 
          });
      };
      // 병렬로 3개의 스트림 실행
      for(let i=0; i<3; i++) burnNetwork();
    }

    // ===== 2. CPU/Memory Workers (ALU + RAM Load) =====
    let workers = [];
    function startCPU() {
      const coreCount = navigator.hardwareConcurrency || 4;
      // 효율 코어와 성능 코어를 모두 쓰기 위해 코어 수보다 많이 할당
      const threadCount = Math.min(16, coreCount * 2); 

      const workerCode = `
        onmessage = function() {
          let running = true;
          // 메모리 부하를 위한 큰 배열 (GC 유도)
          let heavyArray = [];
          
          function run() {
            // 1. 실수 연산 부하
            let a = 1.1, b = 2.2, c = 3.3;
            for(let i=0; i<50000; i++) {
              a = Math.sin(b * c + a);
              b = Math.cos(a * c + b);
              c = Math.tan(a * b + c);
            }
            
            // 2. 메모리 할당/해제 부하 (RAM 전력 소모)
            if (Math.random() > 0.95) {
              heavyArray = new Float32Array(1024 * 1024); // 4MB 할당
              for(let k=0; k<100; k++) heavyArray[k] = Math.random(); // 접근
            } else if (Math.random() > 0.95) {
              heavyArray = []; // 해제
            }

            if(running) setTimeout(run, 0);
          }
          run();
        };
      `;

      const blob = new Blob([workerCode], {type: 'application/javascript'});
      const url = URL.createObjectURL(blob);

      for(let i=0; i<threadCount; i++) {
        const w = new Worker(url);
        w.postMessage('start');
        workers.push(w);
      }
      workerCount = workers.length;
    }

    // ===== 3. WebGL High-Load Shader (GPU Burner) =====
    function initGL() {
      const canvas = document.getElementById('glCanvas');
      // 픽셀 수를 늘리기 위해 DPR을 강제로 높임 (최대 3)
      const dpr = Math.min(window.devicePixelRatio || 1, 3);
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      
      const gl = canvas.getContext('webgl2', { 
        powerPreference: 'high-performance',
        antialias: false,
        alpha: false 
      });

      if(!gl) return;

      const vsSource = `#version 300 es
        in vec4 position;
        void main() { gl_Position = position; }
      `;

      // 컴파일러 최적화 방지 로직이 포함된 쉐이더
      // 결과값(color)을 최종 출력(fragColor)에 반영해야 GPU가 일을 함
      const fsSource = `#version 300 es
        precision highp float;
        uniform float time;
        uniform vec2 resolution;
        out vec4 fragColor;

        void main() {
          vec2 uv = gl_FragCoord.xy / resolution.xy;
          vec3 color = vec3(0.0);
          
          // 무거운 반복 연산
          float s = 0.0;
          for(float i=0.0; i<400.0; i++) {
            // 복잡한 삼각함수와 노이즈 연산
            vec2 p = uv * (10.0 + i * 0.01) + time * 0.1;
            s += cos(p.x * p.y + time) * sin(p.x * 2.0);
            s += sqrt(abs(sin(p.y * 3.14)));
          }
          
          // 중요: 계산된 s값을 색상에 반영해야 함. 
          // 0.0을 곱하면 컴파일러가 루프를 삭제할 수 있음.
          // 아주 작은 값(0.001)을 곱해 눈에는 검게 보이지만 연산은 수행되게 함.
          color = vec3(s) * ${VISUAL_INTENSITY}; 
          
          fragColor = vec4(color, 1.0);
        }
      `;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }

      const program = gl.createProgram();
      gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
      gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
      gl.linkProgram(program);
      gl.useProgram(program);

      // Full screen quad
      const vertices = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      const posLoc = gl.getAttribLocation(program, 'position');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      const timeLoc = gl.getUniformLocation(program, 'time');
      const resLoc = gl.getUniformLocation(program, 'resolution');

      function render(now) {
        if(!running) return;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.uniform1f(timeLoc, now * 0.001);
        gl.uniform2f(resLoc, canvas.width, canvas.height);
        
        // 드로우 콜을 여러번 호출하여 부하 가중
        for(let i=0; i<5; i++) {
           gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        
        frameCount++;
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    }

    // ===== 4. Overlay Update =====
    function updateStats() {
      const mem = performance.memory ? Math.round(performance.memory.usedJSHeapSize/1024/1024) : 'N/A';
      statsEl.innerHTML = `
        Time: ${new Date().toLocaleTimeString()}<br>
        Threads: ${workerCount} Active<br>
        Frames: ${frameCount}<br>
        Network Reqs: ${networkReqs}<br>
        Resolution: ${window.innerWidth}x${window.innerHeight}<br>
        <br>
        <span style="color:#aaa">Tip: Increase screen brightness<br>for max drain.</span>
      `;
      setTimeout(updateStats, 1000);
    }

    // ===== Init =====
    window.onload = () => {
      // 사용자 인터랙션이 없어도 자동 시작되도록 구성했으나,
      // 일부 브라우저는 오디오 컨텍스트 등에서 클릭을 요구할 수 있음.
      // 현재 코드는 순수 연산이라 바로 시작됨.
      startCPU();
      // startNetworkBurner();
      initGL();
      updateStats();
    };

    window.onresize = () => {
      // 리사이즈 시 페이지 리로드로 캔버스 재설정
      window.location.reload();
    };

  </script>
</body>
</html>
