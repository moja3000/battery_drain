<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>iPad Battery Burner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      height: 100%;
      overflow: hidden;
      font-family: ui-monospace, system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    .wrap { position: fixed; inset: 0; background: #000; }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }

    .hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      pointer-events: none;
    }
    .panel {
      pointer-events: auto;
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(0,255,180,0.15);
      border-radius: 12px;
      padding: 10px 12px;
      color: rgba(0,255,180,0.9);
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    }
    .row {
      display: grid;
      grid-template-columns: 120px 1fr 64px;
      gap: 10px;
      align-items: center;
      margin-bottom: 8px;
    }
    .row label { font-size: 12px; opacity: 0.95; }
    input[type="range"] { width: 100%; }

    .row2 {
      display: grid;
      grid-template-columns: 120px 1fr 1fr;
      gap: 10px;
      align-items: center;
      margin-top: 6px;
    }
    input[type="number"]{
      width: 100%;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(0,255,180,0.2);
      color: rgba(0,255,180,0.95);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      outline: none;
    }

    .btns {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    button {
      appearance: none;
      border: 1px solid rgba(0,255,180,0.25);
      background: rgba(0,0,0,0.55);
      color: rgba(0,255,180,0.92);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
    }
    button:active { transform: translateY(1px); }
    .diag {
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-line;
      opacity: 0.95;
      margin-top: 10px;
    }
    .overlay {
      position: absolute;
      bottom: 12px;
      right: 12px;
      pointer-events: none;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(0,255,180,0.12);
      color: rgba(0,255,180,0.9);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-family: ui-monospace, monospace;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c2d"></canvas>
    <canvas id="glc"></canvas>

    <div class="hud">
      <div class="panel">
        <div class="row">
          <label>Burn Level</label>
          <input id="level" type="range" min="0" max="100" value="70" />
          <div id="levelVal" style="text-align:right;font-size:12px;">70</div>
        </div>

        <div class="row2">
          <label>Timer (min)</label>
          <input id="burnMin" type="number" min="1" step="1" value="60" />
          <input id="restMin" type="number" min="0" step="1" value="60" />
        </div>

        <div class="btns">
          <button id="toggle">Pause</button>
          <button id="apply">Apply</button>
          <button id="sched">Scheduler: ON</button>
          <button id="resetCycle">Reset Cycle</button>
          <button id="safe">Safe 40</button>
          <button id="hot">Hot 80</button>
          <button id="max">Max 100</button>
        </div>

        <div class="diag" id="diag"></div>
      </div>
    </div>

    <div class="overlay" id="overlay">starting…</div>
  </div>

<script>
(() => {
  // =======================
  // State
  // =======================
  let running = true;          // 렌더/부하 동작 여부 (Pause/Resume)
  let schedulerOn = true;      // 소모/휴식 스케줄러 동작 여부
  let phase = "burn";          // "burn" | "rest"
  let phaseEndsAt = 0;         // ms timestamp
  let timerId = 0;             // setInterval id

  let fps = 0, last = 0, rafId = 0;
  let workerCount = 0;

  const diag = {
    glOK: false,
    canvasW: 0,
    canvasH: 0,
    rafTicks: 0,
    dpr: 1,
    shaderIters: 0,
    passes: 0,
    particles: 0,
    workers: 0
  };

  // UI
  const levelEl = document.getElementById('level');
  const levelVal = document.getElementById('levelVal');
  const burnMinEl = document.getElementById('burnMin');
  const restMinEl = document.getElementById('restMin');

  const diagEl = document.getElementById('diag');
  const overlayEl = document.getElementById('overlay');

  const toggleBtn = document.getElementById('toggle');
  const applyBtn = document.getElementById('apply');
  const schedBtn = document.getElementById('sched');
  const resetCycleBtn = document.getElementById('resetCycle');

  const safeBtn = document.getElementById('safe');
  const hotBtn  = document.getElementById('hot');
  const maxBtn  = document.getElementById('max');

  // Canvases
  const c2d = document.getElementById('c2d');
  const glc = document.getElementById('glc');
  let ctx;

  // Workers
  let workers = [];

  // WebGL
  let gl, prog, vbo;
  let isGL2 = false;

  // 2D particles
  let particles = [];

  // =======================
  // Burn level -> parameters
  // =======================
  function computeParams(level) {
    const baseDpr = window.devicePixelRatio || 1;

    const dpr = Math.min(5, Math.max(1.5, baseDpr * (1.2 + 1.0*(level/100))));
    const shaderIters = Math.round(250 + 900*(level/100));
    const passes = Math.round(2 + 8*(level/100));

    const hw = Math.max(2, navigator.hardwareConcurrency || 6);
    const workersN = Math.min(12, Math.max(1, Math.round(hw * (0.5 + 1.1*(level/100)))));
    const particlesN = Math.round(600 + 2900*(level/100));

    return { dpr, shaderIters, passes, workersN, particlesN };
  }

  // =======================
  // CPU workers
  // =======================
  function makeWorker() {
    const code = `
      let stop=false;
      onmessage=(e)=>{ if(e.data==='stop') stop=true; };
      function f(x){ return Math.tan(Math.sin(x)*1.618) + Math.sqrt(Math.abs(x%131071)); }
      function spin(){
        let a=0.123456789, b=0.987654321, c=1.41421356237;
        while(!stop){
          for(let i=0;i<8e6;i++){
            a = f(b*c + i*0.000001);
            b = f(a*c + i*0.000002);
            c = f(a*b + i*0.000003);
          }
        }
      }
      spin();
    `;
    return new Worker(URL.createObjectURL(new Blob([code], { type: "application/javascript" })));
  }

  function startCPU(n) {
    stopCPU();
    for (let i=0;i<n;i++) workers.push(makeWorker());
    workerCount = workers.length;
    diag.workers = workerCount;
  }

  function stopCPU() {
    for (const w of workers) { try { w.postMessage('stop'); w.terminate(); } catch(e){} }
    workers = [];
    workerCount = 0;
    diag.workers = 0;
  }

  // =======================
  // Canvas2D
  // =======================
  function init2D(particlesN) {
    ctx = c2d.getContext('2d', { alpha: false });
    const w = c2d.width, h = c2d.height;
    particles = Array.from({length: particlesN}, () => ({
      x: Math.random()*w, y: Math.random()*h,
      vx: (Math.random()-0.5)*2.0, vy: (Math.random()-0.5)*2.0
    }));
    diag.particles = particlesN;
  }

  function draw2D() {
    const w = c2d.width, h = c2d.height;
    ctx.fillStyle = "rgb(0,0,0)";
    ctx.fillRect(0,0,w,h);

    ctx.globalAlpha = 0.04;
    ctx.fillStyle = "#020202";
    for (const p of particles) {
      p.x += p.vx; p.y += p.vy;
      if (p.x<0 || p.x>w) p.vx *= -1;
      if (p.y<0 || p.y>h) p.vy *= -1;
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.globalAlpha = 1.0;
  }

  // =======================
  // WebGL
  // =======================
  function compileShader(gl, src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s));
    }
    return s;
  }

  function buildProgram(shaderIters) {
    if (!gl) {
      gl = glc.getContext("webgl2", { antialias:true, powerPreference:"high-performance", alpha:false })
        || glc.getContext("webgl",  { antialias:true, alpha:false });

      if (!gl) {
        diag.glOK = false;
        return false;
      }
      isGL2 = !!gl.drawArraysInstanced;
    }

    if (prog) {
      try { gl.deleteProgram(prog); } catch(e){}
      prog = null;
    }

    const vertGL2 = `#version 300 es
      in vec2 p;
      void main(){ gl_Position = vec4(p,0.0,1.0); }`;

    const fragGL2 = `#version 300 es
      precision highp float;
      uniform float uT;
      out vec4 C;
      float h(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); }
      float n(vec2 p){
        float s=0.0, a=0.5;
        for(int i=0;i<9;i++){ s += h(p)*a; p*=2.03; a*=0.5; }
        return s;
      }
      void main(){
        vec3 col = vec3(0.1);
        for (int i=0; i<${shaderIters}; i++){
          float t = uT*0.0008 + float(i)*0.03125;
          col = abs(cos(col*t + vec3(
            n(gl_FragCoord.xy+t),
            n(gl_FragCoord.yx-t),
            n(gl_FragCoord.yy+ t)
          )));
        }
        C = vec4(0.0,0.0,0.0,1.0);
      }`;

    const vertGL1 = `
      attribute vec2 p;
      void main(){ gl_Position = vec4(p,0.0,1.0); }`;

    const fragGL1 = `
      precision highp float;
      uniform float uT;
      float h(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); }
      float n(vec2 p){
        float s=0.0, a=0.5;
        for(int i=0;i<7;i++){ s += h(p)*a; p*=2.03; a*=0.5; }
        return s;
      }
      void main(){
        vec3 col = vec3(0.1);
        for (int i=0; i<${Math.max(200, Math.round(shaderIters*0.83))}; i++){
          float t = uT*0.0008 + float(i)*0.03125;
          col = abs(cos(col*t + vec3(
            n(gl_FragCoord.xy+t),
            n(gl_FragCoord.yx-t),
            n(gl_FragCoord.yy+ t)
          )));
        }
        gl_FragColor = vec4(0.0,0.0,0.0,1.0);
      }`;

    const vs = compileShader(gl, isGL2 ? vertGL2 : vertGL1, gl.VERTEX_SHADER);
    const fs = compileShader(gl, isGL2 ? fragGL2 : fragGL1, gl.FRAGMENT_SHADER);

    prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
      diag.glOK = false;
      return false;
    }

    if (!vbo) {
      const quad = new Float32Array([-1,-1,  1,-1,  -1,1,   -1,1,  1,-1,  1,1]);
      vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
    }

    diag.glOK = true;
    diag.shaderIters = shaderIters;
    return true;
  }

  function drawGL(t, passes) {
    if (!gl || !prog) return;

    const w = glc.width, h = glc.height;
    gl.viewport(0,0,w,h);
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.useProgram(prog);

    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const loc = gl.getAttribLocation(prog, "p");
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

    const uT = gl.getUniformLocation(prog, "uT");
    gl.uniform1f(uT, t);

    for (let k=0; k<passes; k++) gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  // =======================
  // Apply settings (level)
  // =======================
  let current = computeParams(+levelEl.value);

  function setHiDPISize(dpr) {
    const W = window.innerWidth;
    const H = window.innerHeight;
    const ww = Math.floor(W * dpr);
    const hh = Math.floor(H * dpr);

    c2d.width = ww; c2d.height = hh;
    glc.width = ww; glc.height = hh;

    diag.canvasW = ww;
    diag.canvasH = hh;
    diag.dpr = dpr;
  }

  function applyLevel(level) {
    current = computeParams(level);
    setHiDPISize(current.dpr);
    init2D(current.particlesN);
    buildProgram(current.shaderIters);

    // burn 상태일 때만 워커 동작 (휴식 중엔 stopCPU)
    if (phase === "burn") startCPU(current.workersN);

    diag.passes = current.passes;
    renderDiag(16);
  }

  // =======================
  // Timer (Burn/Rest cycle)
  // =======================
  function minsToMs(m) { return Math.max(0, Math.floor(m)) * 60 * 1000; }

  function scheduleNextPhase(nextPhase) {
    phase = nextPhase;

    const burnMs = minsToMs(+burnMinEl.value || 0);
    const restMs = minsToMs(+restMinEl.value || 0);

    // 0분 입력 같은 극단 케이스 방지: burn은 최소 1분 권장
    const duration = (phase === "burn") ? (burnMs || 60*1000) : restMs;

    phaseEndsAt = Date.now() + duration;

    if (phase === "burn") {
      // 부하 켜기
      startCPU(current.workersN);
      running = true;
      toggleBtn.textContent = "Pause";
    } else {
      // 휴식: CPU 워커까지 끔, 렌더도 끔 (진짜 휴식)
      stopCPU();
      running = false;
      toggleBtn.textContent = "Resume";
    }
  }

  function resetCycle() {
    scheduleNextPhase("burn");
  }

  function tickScheduler() {
    if (!schedulerOn) return;

    const now = Date.now();
    if (phaseEndsAt <= 0) return;

    if (now >= phaseEndsAt) {
      scheduleNextPhase(phase === "burn" ? "rest" : "burn");
    }
  }

  function formatRemain(ms) {
    const s = Math.max(0, Math.floor(ms/1000));
    const mm = Math.floor(s/60);
    const ss = s % 60;
    return `${mm}m ${String(ss).padStart(2,'0')}s`;
  }

  // =======================
  // Loop & HUD
  // =======================
  function renderDiag(dt) {
    fps = Math.max(1, Math.round(1000/Math.max(1, dt || 16)));
    const gpuEst = Math.min(100, Math.round(100 * (1 - Math.exp(-(dt||16) / 6))));

    const remain = phaseEndsAt ? formatRemain(phaseEndsAt - Date.now()) : "--";
    const phaseText = schedulerOn ? `${phase.toUpperCase()} (${remain})` : "MANUAL";

    overlayEl.textContent = `Phase ${phaseText} | FPS ${fps} | GPU~${gpuEst}% | Level ${levelEl.value}`;

    diagEl.textContent =
`GL OK: ${diag.glOK ? "yes" : "no"}
Phase: ${phaseText}
Canvas(px): ${diag.canvasW}×${diag.canvasH} (dpr≈${diag.dpr.toFixed(2)})
Workers: ${workerCount}
2D particles: ${diag.particles}
Shader iters: ${diag.shaderIters}
GL passes/frame: ${diag.passes}
RAF ticks: ${diag.rafTicks}`;
  }

  function loop(ts) {
    const dt = ts - last; last = ts;

    if (running) {
      draw2D();
      drawGL(ts, current.passes);
      setTimeout(() => {
        if (running) drawGL(ts + 0.5, Math.max(1, Math.floor(current.passes*0.6)));
      }, 0);

      diag.rafTicks++;
      renderDiag(dt);
    } else {
      // 휴식/정지 중에도 HUD는 갱신
      renderDiag(16);
    }

    rafId = requestAnimationFrame(loop);
  }

  // =======================
  // UI handlers
  // =======================
  levelEl.addEventListener('input', () => { levelVal.textContent = levelEl.value; });

  applyBtn.addEventListener('click', () => {
    // 레벨 파라미터만 반영. 스케줄 phase는 유지.
    applyLevel(+levelEl.value);
  });

  safeBtn.addEventListener('click', () => {
    levelEl.value = 40; levelVal.textContent = "40"; applyLevel(40);
  });
  hotBtn.addEventListener('click', () => {
    levelEl.value = 80; levelVal.textContent = "80"; applyLevel(80);
  });
  maxBtn.addEventListener('click', () => {
    levelEl.value = 100; levelVal.textContent = "100"; applyLevel(100);
  });

  toggleBtn.addEventListener('click', () => {
    // Pause는 즉시 부하를 멈추고(워커도 멈춤), Resume은 burn일 때만 재시작
    if (running) {
      running = false;
      stopCPU();
      toggleBtn.textContent = "Resume";
    } else {
      // 휴식 phase라면 Resume 눌러도 "휴식 정책"이 우선.
      if (schedulerOn && phase === "rest") return;
      running = true;
      startCPU(current.workersN);
      toggleBtn.textContent = "Pause";
      last = performance.now();
    }
  });

  schedBtn.addEventListener('click', () => {
    schedulerOn = !schedulerOn;
    schedBtn.textContent = `Scheduler: ${schedulerOn ? "ON" : "OFF"}`;

    if (schedulerOn) {
      // 다시 켜면 현재 설정으로 burn부터 재시작
      resetCycle();
    } else {
      // 끄면 MANUAL 모드: 현재 running 상태 유지(사용자가 Pause/Resume로 제어)
      phaseEndsAt = 0;
      phase = "burn";
    }
  });

  resetCycleBtn.addEventListener('click', () => {
    resetCycle();
  });

  // Timer 값 바꾸면 다음 사이클부터 반영되게 두었고,
  // 즉시 반영하고 싶으면 Reset Cycle 버튼을 누르면 됨.

  window.addEventListener('resize', () => {
    applyLevel(+levelEl.value);
  });

  window.addEventListener('beforeunload', () => {
    try { cancelAnimationFrame(rafId); } catch(e){}
    try { clearInterval(timerId); } catch(e){}
    stopCPU();
  });

  // =======================
  // Start immediately
  // =======================
  levelVal.textContent = levelEl.value;

  // 초기 적용
  applyLevel(+levelEl.value);

  // 스케줄러 시작: 첫 로드부터 바로 "소모(BURN)" 시작
  resetCycle();

  // scheduler tick (1초마다)
  timerId = setInterval(() => {
    tickScheduler();
  }, 1000);

  last = performance.now();
  rafId = requestAnimationFrame(loop);
})();
</script>
</body>
</html>
